\documentclass{article}

\usepackage{algpseudocode}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{fontspec}
\usepackage{mathtools}
\usepackage{microtype}
\usepackage[table,xcdraw]{xcolor}

\title{Balanced Binary Search Trees}
\author{Florian Kretlow}

\begin{document}

\section{Red-Black-Tree}

\subsection{Introduction and general properties}
A red-black-tree is a self-balancing binary search tree. In addition to the invariants
of the latter, the former garantees that the tree remains roughly balanced even when it
receives input sequences that lead to pathological cases for normal binary search trees
(sorted input).

How does it work? We assign one of two colors (traditionally red and black) to every
node in the tree and execute the insertion and deletion operations in such a way that the
following invariants hold:

\begin{enumerate}[label=(\arabic*)]
\item Every node is either red or black.
\item If a node is red, it doesn't have a red child.
\item All paths from the root to a leaf go through the same number of black nodes.
\end{enumerate}

Now, if \(b\) is the number of black nodes on every path from the root to a leaf, then
the shortest such path (which contains no red nodes at all) has a length of \(b\), and
the longest such path (where black and red nodes alternate) has a length of
\(2b\). In other words, a red-black-tree guarantees that the lengths of any two paths
from the root to a leaf (i.e. the depths of any two leaf nodes) differ by at most a
factor of 2:

\[
\forall \text{ leaf nodes } l_{i}, l_{j} \in T : \text{depth}(l_i) \leq 2 \cdot
\text{depth}(l_j)
\]

In the following, let a \emph{group} of nodes in a red-black-tree denote either \emph{any
black node together with all its red child nodes,} or the \emph{null-group} which
contains no nodes at all.  By invariant (2) we know that the nearest descendant nodes
below a group must be black nodes, and as such they form the roots of groups themselves.
Thus we can rephrase invariant (3) like so:

\begin{enumerate}[label=(\arabic*)]
\setcounter{enumi}{2}
\item All paths from the root to a leaf go through the same number of groups.
\end{enumerate}

Obviously, a group that is not the null-group contains either 0, 1 or 2 red child nodes.
If it contains 0 red child nodes, it consists of 1 node (the black root) and has 2
descending groups (a). If it contains 1 red child node, it consists of 2 nodes (the
black root and one red child)) and it has 3 descending groups (b). And if it contains 2
red child nodes, it consists of 3 nodes (the black root and one red child on either
side) and it has 4 descending groups (c). In the latter case the group is said to be
\emph{full}. If a group contains 1 red child node, it is possible to rotate it in such a
way that the former red child becomes the black root of the group, and the former black
root becomes a red child on the opposite site; this rotation does not affect any
descendant groups.

In order to preserve invariant (3), inserting a node into a red-black-tree must not add
a new group to the tree (except at the very root where the addition affects all paths
equally). Likewise, deleting a node from the tree must not remove a group entirely
(again, except at the root). The fact that groups can have variable numbers of red nodes
provides us with enough flexibility though: We can shift nodes between groups and rotate
sub-trees to make sure we have some leeway at the position where we need to insert or
delete a node.

\subsection{Insertion}
Insertion into a normal binary search tree is straightforward. You start at the root,
and then you always go left if the new value is less than the current value, or you go
right if it is greater. When you've nowhere left to go (i.e. you'd need to go left but
there's no left child, or the other way around) you simply add the value at that
position.

Insertion into a red-black-tree works similarly but it must not add a new group
somewhere down the tree because that would violate invariant (3). Therefore insertion is
not possible if the direct parent of the to-be-added node is part of a full group. The
solution is to transform the group the parent belongs to in such a way that it contains
at most one red node. Then we can add the new node as a red child to the group, after
rotating it first if necessary.

How to transform a full group into a not-so-full group? It's possible to shift one
node of a full group up into its ancestor group, provided the ancestor group is not
full. That's then what we need to ensure: We start at the root, and in every group we
walk through on the way down to the insertion position we make sure it's not a full
group. Maybe in the next group further down we'll shift a node up, making the previous
group full again, but that doesn't matter. We only ever care about the current group so
when we arrive at our destination we can happily add a new node.

\subsection{Deletion}
Deletion works similarly. Only, on the way down to the node we want to delete we ensure
that every group we walk through is not an empty group.


\end{document}
