\documentclass{article}

\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{fontspec}
\usepackage{mathtools}
\usepackage{microtype}
\usepackage[table,xcdraw]{xcolor}

\title{Balanced Binary Search Trees}
\author{Florian Kretlow}

\begin{document}

\section{Red-Black-Tree}

\subsection{Introduction and general properties}
A red-black-tree is a self-balancing binary search tree. In addition to the invariants
of the latter, the former garantees that the tree remains roughly balanced even when it
receives input sequences that lead to pathological cases for normal binary search trees
(sorted input).

How does it work? We assign one of two colors (traditionally red and black) to every
node in the tree and execute the insertion and deletion operations in such a way that the
following invariants hold:

\begin{enumerate}[label=(\arabic*)]
\item Every node is either red or black.
\item If a node is red, it doesn't have a red child.
\item The number of black nodes on every path from the root to a leaf is the same.
\end{enumerate}

Now, if \(b\) is the number of black nodes on every path from the root to a leaf, then
the shortest such path (which contains no red nodes at all) has a length of \(b\), and
the longest such path (where there's a red node after every black node) has a length of
\(2b\). In other words, a red-black-tree guarantees that the lengths of any two paths
from the root to a leaf (i.e. the depths of any two leaf nodes) differ by at most a
factor of two:

\[
\forall \text{ leaf nodes } l_{i}, l_{j} \in T : \text{depth}(l_i) \leq 2 \cdot
\text{depth}(l_j)
\]

In the following, let a \emph{group} of nodes in a red-black-tree denote either any
black node together with all its red child nodes, or the \emph{null-group} which
contains no nodes at all.  By invariant (2) we know that the nearest descendant nodes
outside of a group must be black nodes, and as such they form the roots of groups
themselves. Thus we can rephrase invariant (3) like so:

\begin{enumerate}[label=(\arabic*)]
\setcounter{enumi}{2}
\item The number of groups on every path from the root to a leaf is the same.
\end{enumerate}

Obviously, a group that is not the null-group contains either 0, 1 or 2 red child nodes.
If it contains 0 red child nodes, it has 2 descending groups (a). If it contains 1 red
child node, it has 3 descending groups (b). And if it contains 2 red child nodes, it has
4 descending groups (c). In the latter case the group is said to be \emph{full}. If a
group contains 1 red child node, it is possible to rotate it in such a way that the
former red child becomes the black root of the group, and the former black root becomes
a red child on the opposite site; this rotation does not affect any descendant groups.

In order to preserve invariant (3), inserting a node into a red-black-tree must
not add a new group of nodes to the tree (except at the very root where the addition
affects all paths equally). Likewise, deleting a node from the tree must not remove a
group entirely (again, except at the root). The fact that groups can have variable
numbers of red nodes provides us with enough flexibility though: We can shift nodes
between groups and rotate sub-trees to make sure we have some leeway at the position
where we need to insert or delete a node.

\subsection{Insertion}
Insertion into a normal binary search tree is straightforward. You start at the root,
and then you always go left if the new value is less than the current value, or you go
right if it is greater. If there's nowhere to go (i.e. you'd need to go left but there's
no left child, or the other way around) you simply add the value at that position.

\end{document}
